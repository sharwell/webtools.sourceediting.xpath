<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xsl:stylesheet [
  <!ENTITY nl "&#xa;">
  <!ENTITY t "&#x9;">
]>
<xsl:stylesheet xmlns:x="http://www.w3.org/2005/02/query-test-XQTSCatalog" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0">
  <xsl:template match="/">
    <xsl:apply-templates select="x:test-group[x:test-case[@is-XPath2='true']]"/>
  </xsl:template>

  <xsl:template match="x:test-group">
    <xsl:variable name="classname" select="concat('Test_',replace(@name,'-','_'))"/>
    <xsl:result-document href="org/eclipse/wst/xml/xpath2/test/{$classname}.java" method="text">
      <xsl:apply-templates select="." mode="testFile">
        <xsl:with-param name="classname" select="$classname"/>
      </xsl:apply-templates>
    </xsl:result-document>
  </xsl:template>

  <xsl:template match="x:test-group" mode="testFile">
    <xsl:param name="classname"/>

    <xsl:call-template name="Header"/>
    <xsl:call-template name="PackageDeclaration"/>
    <xsl:call-template name="Imports"/>
    <xsl:apply-templates select="." mode="testClass">
      <xsl:with-param name="classname" select="$classname"/>
    </xsl:apply-templates>
  </xsl:template>

  <xsl:template name="Header">
    <xsl:text><![CDATA[/*
 * This file was generated by a tool. Do not edit.
 */
]]></xsl:text>
  </xsl:template>
  <xsl:template name="PackageDeclaration">
    <xsl:text>package org.eclipse.wst.xml.xpath2.test;&nl;&nl;</xsl:text>
  </xsl:template>

  <xsl:template name="Imports">
    <xsl:text><![CDATA[import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.namespace.QName;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.eclipse.wst.xml.xpath2.api.DynamicContext;
import org.eclipse.wst.xml.xpath2.api.ResultSequence;
import org.eclipse.wst.xml.xpath2.api.StaticContext;
import org.eclipse.wst.xml.xpath2.api.XPath2Expression;
import org.eclipse.wst.xml.xpath2.processor.DynamicError;
import org.eclipse.wst.xml.xpath2.processor.StaticError;
import org.eclipse.wst.xml.xpath2.processor.internal.function.FnCollection;
import org.eclipse.wst.xml.xpath2.processor.internal.types.DocType;
import org.eclipse.wst.xml.xpath2.processor.internal.types.NodeItemTypeImpl;
import org.eclipse.wst.xml.xpath2.processor.internal.types.XSAnyURI;
import org.hamcrest.CoreMatchers;
import org.hamcrest.Matcher;
import org.junit.Assert;
import org.junit.Test;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.xml.sax.SAXException;

]]></xsl:text>
  </xsl:template>

  <xsl:template match="x:test-group" mode="testClass">
    <xsl:param name="classname"/>

    <xsl:text>public class </xsl:text>
    <xsl:value-of select="$classname"/>
    <xsl:text> extends XPathTestBase {&nl;</xsl:text>
    <xsl:apply-templates select="x:test-case[@is-XPath2='true']"/>
    <xsl:text>&nl;}</xsl:text>
  </xsl:template>

  <xsl:template match="x:test-case">
    <xsl:variable name="methodName" select="replace(@name,'-','_')"/>
    <xsl:text>&nl;&t;@Test&nl;</xsl:text>

    <xsl:text>&t;public void </xsl:text>
    <xsl:value-of select="$methodName"/>
    <xsl:text>() throws IOException, ParserConfigurationException, SAXException, TransformerException {&nl;</xsl:text>

    <xsl:text>&t;&t;String filePath = "</xsl:text>
    <xsl:value-of select="@FilePath"/>
    <xsl:text>";&nl;</xsl:text>

    <xsl:if test="x:input-URI | x:defaultCollection">
      <xsl:text>&t;&t;Map&lt;String, List&lt;Document&gt;&gt; collections = new HashMap&lt;String, List&lt;Document&gt;&gt;();&nl;</xsl:text>
    </xsl:if>

    <xsl:text>&nl;</xsl:text>
    <xsl:text>&t;&t;StaticContext staticContext = createStaticContextBuilder()</xsl:text>
    <xsl:for-each select="x:input-URI">
      <xsl:text>&nl;&t;&t;&t;.withVariable(new QName("</xsl:text>
      <xsl:value-of select="@variable"/>
      <xsl:text>"), new XSAnyURI().getItemType())</xsl:text>
    </xsl:for-each>
    <xsl:for-each select="x:input-file">
      <xsl:text>&nl;&t;&t;&t;.withVariable(new QName("</xsl:text>
      <xsl:value-of select="@variable"/>
      <xsl:text>"), new NodeItemTypeImpl(Node.DOCUMENT_NODE))</xsl:text>
    </xsl:for-each>
    <xsl:text>;&nl;</xsl:text>

    <xsl:apply-templates select="x:input-file | x:input-URI | x:defaultCollection | x:contextItem" mode="read"/>

    <xsl:text>&nl;</xsl:text>
    <xsl:text>&t;&t;DynamicContext dynamicContext = createDynamicContextBuilder(staticContext)</xsl:text>
    <xsl:for-each select="x:input-URI">
      <xsl:text>&nl;&t;&t;&t;.withVariable(new QName("</xsl:text>
      <xsl:value-of select="@variable"/>
      <xsl:text>"), new XSAnyURI("</xsl:text>
      <xsl:apply-templates select="." mode="withVariable"/>
      <xsl:text>"))</xsl:text>
    </xsl:for-each>
    <xsl:for-each select="x:input-file">
      <xsl:text>&nl;&t;&t;&t;.withVariable(new QName("</xsl:text>
      <xsl:value-of select="@variable"/>
      <xsl:text>"), new DocType(</xsl:text>
      <xsl:value-of select="replace(@variable,'-','_')"/>
      <xsl:text>, staticContext.getTypeModel()))</xsl:text>
    </xsl:for-each>
    <xsl:if test="x:input-URI | x:defaultCollection">
      <xsl:text>&nl;&t;&t;&t;.withCollections(collections)</xsl:text>
    </xsl:if>
    <xsl:text>;&nl;</xsl:text>

    <xsl:apply-templates select="x:query">
      <xsl:with-param name="testName" select="@name"/>
      <xsl:with-param name="compare" select="x:output-file/@compare"/>
      <xsl:with-param name="outputName" select="x:output-file/text()"/>
      <xsl:with-param name="expectedError" select="x:expected-error/text()"/>
      <xsl:with-param name="contextItems" select="x:contextItem/text()"/>
    </xsl:apply-templates>

    <xsl:text>&t;}&nl;</xsl:text>
  </xsl:template>

  <xsl:template match="x:input-URI" mode="read">
    <xsl:variable name="inputId" select="text()"/>
    <xsl:variable name="collection" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:collection[@ID=$inputId]"/>
    <xsl:if test="$collection">
      <xsl:call-template name="loadCollection">
        <xsl:with-param name="variableName" select="replace(@variable,'-','_')"/>
        <xsl:with-param name="collection" select="$collection"/>
        <xsl:with-param name="collectionName">
          <xsl:text>"</xsl:text>
          <xsl:value-of select="text()"/>
          <xsl:text>"</xsl:text>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <xsl:template match="x:input-URI" mode="withVariable">
    <xsl:variable name="inputId" select="text()"/>
    <xsl:variable name="source" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:source[@ID=$inputId]"/>
    <xsl:variable name="collection" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:collection[@ID=$inputId]"/>
    <xsl:choose>
      <xsl:when test="$collection">
        <xsl:value-of select="$inputId"/>
      </xsl:when>
      <xsl:when test="$source">
        <xsl:value-of select="$source/@FileName"/>
      </xsl:when>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="x:defaultCollection" mode="read">
    <xsl:variable name="inputId" select="text()"/>
    <xsl:call-template name="loadCollection">
      <xsl:with-param name="variableName" select="'defaultCollection'"/>
      <xsl:with-param name="collection" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:collection[@ID=$inputId]"/>
      <xsl:with-param name="collectionName" select="'FnCollection.DEFAULT_COLLECTION_URI'"/>
    </xsl:call-template>
  </xsl:template>

  <xsl:template name="loadCollection">
    <xsl:param name="variableName"/>
    <xsl:param name="collection"/>
    <xsl:param name="collectionName"/>

    <xsl:text>&nl;</xsl:text>
    <xsl:text>&t;&t;List&lt;Document&gt; </xsl:text>
    <xsl:value-of select="$variableName"/>
    <xsl:text> = new ArrayList&lt;Document&gt;();&nl;</xsl:text>

    <xsl:for-each select="$collection/x:input-document">
      <xsl:variable name="inputDocumentVariable" select="replace(text(),'-','_')"/>
      <xsl:variable name="inputDocumentId" select="text()"/>
      <xsl:variable name="source" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:source[@ID=$inputDocumentId]"/>
      <xsl:variable name="fileName" select="$source/@FileName"/>
      <xsl:variable name="schema">
        <xsl:choose>
          <xsl:when test="$source/@schema">
            <xsl:variable name="schemaNode" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:schema[@ID=($source/@schema)]"/>
            <xsl:value-of select="$schemaNode/@FileName"/>
          </xsl:when>
          <xsl:otherwise></xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:choose>
        <xsl:when test="ends-with($fileName, '.xml')">
          <xsl:text>&t;&t;String raw_</xsl:text>
          <xsl:value-of select="$inputDocumentVariable"/>
          <xsl:text> = readFile("</xsl:text>
          <xsl:value-of select="$fileName"/>
          <xsl:text>");&nl;</xsl:text>

          <xsl:text>&t;&t;Document </xsl:text>
          <xsl:value-of select="$inputDocumentVariable"/>
          <xsl:text> = getDocumentBuilder("</xsl:text>
          <xsl:value-of select="$schema"/>
          <xsl:text>").parse(new ByteArrayInputStream(raw_</xsl:text>
          <xsl:value-of select="$inputDocumentVariable"/>
          <xsl:text>.getBytes("UTF-8")), staticContext.getBaseUri().toString() + "</xsl:text>
          <xsl:value-of select="$fileName"/>
          <xsl:text>");&nl;</xsl:text>

          <xsl:text>&t;&t;</xsl:text>
          <xsl:value-of select="$variableName"/>
          <xsl:text>.add(</xsl:text>
          <xsl:value-of select="$inputDocumentVariable"/>
          <xsl:text>);&nl;</xsl:text>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>&t;&t;Assert.fail("Not yet implemented.");&nl;</xsl:text>
          <!--String <xsl:value-of select="$inputDocumentVariable"/> = readFile("<xsl:value-of select="$fileName"/>");-->
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>

    <xsl:text>&t;&t;collections.put(staticContext.getBaseUri().resolve(</xsl:text>
    <xsl:value-of select="$collectionName"/>
    <xsl:text>).toString(), </xsl:text>
    <xsl:value-of select="$variableName"/>
    <xsl:text>);&nl;</xsl:text>
  </xsl:template>

  <xsl:template match="x:contextItem" mode="read">
    <xsl:variable name="variableName" select="concat('context_',replace(text(),'-','_'))"/>
    <xsl:variable name="inputId" select="text()"/>
    <xsl:variable name="source" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:source[@ID=$inputId]"/>
    <xsl:variable name="fileName" select="$source/@FileName"/>
    <xsl:variable name="schema">
      <xsl:choose>
        <xsl:when test="$source/@schema">
          <xsl:variable name="schemaNode" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:schema[@ID=($source/@schema)]"/>
          <xsl:value-of select="$schemaNode/@FileName"/>
        </xsl:when>
        <xsl:otherwise></xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="ends-with($fileName, '.xml')">
        <xsl:text>&t;&t;String raw_</xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text> = readFile("</xsl:text>
        <xsl:value-of select="$fileName"/>
        <xsl:text>");&nl;</xsl:text>

        <xsl:text>&t;&t;Document </xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text> = getDocumentBuilder("</xsl:text>
        <xsl:value-of select="$schema"/>
        <xsl:text>").parse(new ByteArrayInputStream(raw_</xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text>.getBytes("UTF-8")), staticContext.getBaseUri().toString() + "</xsl:text>
        <xsl:value-of select="$fileName"/>
        <xsl:text>");&nl;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>&t;&t;String </xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text> = readFile("</xsl:text>
        <xsl:value-of select="$fileName"/>
        <xsl:text>");&nl;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="x:input-file" mode="read">
    <xsl:variable name="variableName" select="replace(@variable,'-','_')"/>
    <xsl:variable name="inputId" select="text()"/>
    <xsl:variable name="source" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:source[@ID=$inputId]"/>
    <xsl:variable name="fileName" select="$source/@FileName"/>
    <xsl:variable name="schema">
      <xsl:choose>
        <xsl:when test="$source/@schema">
          <xsl:variable name="schemaNode" select="doc('../XQTSCatalog.xml')/x:test-suite/x:sources/x:schema[@ID=($source/@schema)]"/>
          <xsl:value-of select="$schemaNode/@FileName"/>
        </xsl:when>
        <xsl:otherwise></xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="ends-with($fileName, '.xml')">
        <xsl:text>&nl;</xsl:text>
        <xsl:text>&t;&t;String raw_</xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text> = readFile("</xsl:text>
        <xsl:value-of select="$fileName"/>
        <xsl:text>");&nl;</xsl:text>

        <xsl:text>&t;&t;Document </xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text> = getDocumentBuilder("</xsl:text>
        <xsl:value-of select="$schema"/>
        <xsl:text>").parse(new ByteArrayInputStream(raw_</xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text>.getBytes("UTF-8")), staticContext.getBaseUri().toString() + "</xsl:text>
        <xsl:value-of select="$fileName"/>
        <xsl:text>");&nl;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>&nl;</xsl:text>
        <xsl:text>&t;&t;String </xsl:text>
        <xsl:value-of select="$variableName"/>
        <xsl:text> = readFile("</xsl:text>
        <xsl:value-of select="$fileName"/>
        <xsl:text>");&nl;</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="x:query">
    <xsl:param name="testName"/>
    <xsl:param name="outputName"/>
    <xsl:param name="compare"/>
    <xsl:param name="expectedError"/>
    <xsl:param name="contextItems"/>

    <xsl:text>&nl;</xsl:text>
    <xsl:text>&t;&t;String query = readFile("Queries/XQuery/" + filePath + "</xsl:text>
    <xsl:value-of select="@name"/>
    <xsl:text>.xq");&nl;</xsl:text>

    <xsl:text>&t;&t;if (isDebug()) {&nl;</xsl:text>
    <xsl:text>&t;&t;&t;System.out.println(query);&nl;</xsl:text>
    <xsl:text>&t;&t;}&nl;</xsl:text>
    <xsl:text>&t;&t;query = query.replaceAll("declare\\s+variable\\s+\\$[a-zA-Z_-][a-zA-Z0-9_-]*\\s+external\\s*;", "");&nl;</xsl:text>
    <xsl:text>&t;&t;query = query.replaceAll("import\\s+schema\\s+namespace\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*=\\s*\"[^\"]*\"\\s*;", "");&nl;</xsl:text>

    <xsl:if test="$outputName">
      <xsl:text>&nl;</xsl:text>
      <xsl:text>&t;&t;List&lt;Matcher&lt;? super String&gt;&gt; expectedMatchers = new ArrayList&lt;Matcher&lt;? super String&gt;&gt;();&nl;</xsl:text>

      <xsl:for-each select="$outputName">
        <xsl:choose>
          <xsl:when test="$compare='XML'">
            <xsl:text>&t;&t;expectedMatchers.add(CoreMatchers.is(xmlEqualTo(readFile("ExpectedTestResults/" + filePath + "</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>"))));&nl;</xsl:text>
          </xsl:when>
          <xsl:when test="$compare='Fragment' or $compare='Inspect'">
            <xsl:text>&t;&t;expectedMatchers.add(CoreMatchers.is(xmlFragmentEqualTo(readFile("ExpectedTestResults/" + filePath + "</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>"))));&nl;</xsl:text>
          </xsl:when>
          <xsl:when test="$compare='Text'">
            <xsl:text>&t;&t;expectedMatchers.add(CoreMatchers.is(CoreMatchers.equalTo(readFile("ExpectedTestResults/" + filePath + "</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>"))));&nl;</xsl:text>
          </xsl:when>
          <xsl:when test="$compare='Ignore'"/>
          <xsl:otherwise>
            <xsl:text>&t;&t;Assert.fail("Shouldn't reach this point.");&nl;</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:for-each>

      <xsl:if test="$compare='Inspect'">
        <xsl:text>&t;&t;if (!checkInspections()) {&nl;</xsl:text>
        <xsl:text>&t;&t;&t;expectedMatchers.add(CoreMatchers.anything());&nl;</xsl:text>
        <xsl:text>&t;&t;}&nl;</xsl:text>
      </xsl:if>
    </xsl:if>

    <xsl:choose>
      <xsl:when test="$expectedError">
        <xsl:if test="$expectedError!='*'">
          <xsl:text>&nl;</xsl:text>
          <xsl:text>&t;&t;List&lt;Matcher&lt;? super String&gt;&gt; matchers = new ArrayList&lt;Matcher&lt;? super String&gt;&gt;();&nl;</xsl:text>
          <xsl:for-each select="$expectedError">
            <xsl:text>&t;&t;matchers.add(CoreMatchers.is(CoreMatchers.equalTo("</xsl:text>
            <xsl:value-of select="."/>
            <xsl:text>")));&nl;</xsl:text>
          </xsl:for-each>
        </xsl:if>
        <xsl:text>&nl;</xsl:text>
        <xsl:text>&t;&t;try {&nl;</xsl:text>
        <xsl:text>&t;&t;&t;XPath2Expression expression = getEngine().parseExpression(query, staticContext);&nl;</xsl:text>
        <xsl:text>&t;&t;&t;Node[] contextItems = new Node[] {</xsl:text>
        <xsl:for-each select="$contextItems">
          <xsl:text> context_</xsl:text>
          <xsl:value-of select="replace(.,'-','_')"/>
          <xsl:if test="position() != last()">
            <xsl:text>,</xsl:text>
          </xsl:if>
        </xsl:for-each>
        <xsl:text> };&nl;</xsl:text>
        <xsl:text>&t;&t;&t;ResultSequence result = expression.evaluate(dynamicContext, contextItems);&nl;</xsl:text>
        <xsl:choose>
          <xsl:when test="$outputName">

            <xsl:text>&t;&t;String actual = serializeResultSequence(result);&nl;</xsl:text>
            <xsl:if test="$compare != 'Ignore'">
              <xsl:text>&t;&t;Assert.assertThat(actual, CoreMatchers.anyOf(expectedMatchers));&nl;</xsl:text>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>&t;&t;&t;Assert.fail("Expected an exception: </xsl:text>
            <xsl:for-each select="$expectedError">
              <xsl:value-of select="."/>
              <xsl:if test="position() != last()">
                <xsl:text> or </xsl:text>
              </xsl:if>
            </xsl:for-each>
            <xsl:text>");&nl;</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
        <xsl:text>&t;&t;} catch (DynamicError ex) {&nl;</xsl:text>
        <xsl:if test="$expectedError!='*'">
          <xsl:text>&t;&t;&t;Assert.assertThat(ex.code(), CoreMatchers.anyOf(matchers));&nl;</xsl:text>
        </xsl:if>
        <xsl:text>&t;&t;} catch (StaticError ex) {&nl;</xsl:text>
        <xsl:if test="$expectedError!='*'">
          <xsl:text>&t;&t;&t;Assert.assertThat(ex.code(), CoreMatchers.anyOf(matchers));&nl;</xsl:text>
        </xsl:if>
        <xsl:text>&t;&t;}&nl;</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>&nl;</xsl:text>
        <xsl:text>&t;&t;XPath2Expression expression = getEngine().parseExpression(query, staticContext);&nl;</xsl:text>
        <xsl:text>&t;&t;Node[] contextItems = new Node[] {</xsl:text>
        <xsl:for-each select="$contextItems">
          <xsl:text> context_</xsl:text>
          <xsl:value-of select="replace(.,'-','_')"/>
          <xsl:if test="position() != last()">
            <xsl:text>,</xsl:text>
          </xsl:if>
        </xsl:for-each>
        <xsl:text> };&nl;</xsl:text>
        <xsl:text>&t;&t;ResultSequence result = expression.evaluate(dynamicContext, contextItems);&nl;</xsl:text>

        <xsl:text>&nl;</xsl:text>
        <xsl:text>&t;&t;String actual = serializeResultSequence(result);&nl;</xsl:text>
        <xsl:if test="$compare != 'Ignore'">
          <xsl:text>&t;&t;Assert.assertThat(actual, CoreMatchers.anyOf(expectedMatchers));&nl;</xsl:text>
        </xsl:if>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- no output for anything else -->
  <xsl:template match="node()|@*"/>
</xsl:stylesheet>
